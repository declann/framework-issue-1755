/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/calcudata-experiments@0.4.0/dist/index.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as e from"./https:/cdn.jsdelivr.net/npm/@tidyjs/tidy/+esm";import*as n from"./https:/cdn.jsdelivr.net/npm/compassql/+esm";import{tableToIPC as t,tableFromArrays as o}from"./https:/cdn.jsdelivr.net/npm/@uwdata/flechette/dist/flechette.mjs";function r({firstName:e,lastName:n,age:t}){console.log("Hello!"),console.log(`Your name is ${e+(n??"")}`),t&&console.log(`Your age is ${t}`)}var i=(e,n)=>{if(!e||!e.length)return[];var t=e[0],o=e.slice(1),r=[];for(var l in t)for(var s=0;s<t[l].length;s++){var u=a(n);if(u[l]=t[l][s],o.length){var m=i(o,u);r=r.concat(m)}else r.push(u)}return r};function a(e){var n={};for(var t in e)n[t]=e[t];return n}var l=({models:n,introspections:t=[],input_domains:o,input_cursors:r,outputs:a,pivot:l=!1})=>{if(console.log("HI"),!n.length)return;let s={model_id:n.map(((e,n)=>n)),input_cursor_id:r.map(((e,n)=>n)),formula:a};Object.entries(o).forEach((([e,n])=>{s[e]=n}));let u=i(Object.entries(s).map((([e,n])=>({[e]:n}))));u=u.map((e=>({...r[e.input_cursor_id],...e})));let m=[];return u.forEach((e=>{let t="ERROR";try{t=n[e.model_id][e.formula](e)}catch(e){console.log(e)}let o={};Object.entries(e).forEach((([e,n])=>{r[0][e],o[e]=n})),o.formula=e.formula,m.push({...o,value:t})})),l?e.tidy(m,e.pivotWider({namesFrom:"formula",valuesFrom:"value"})):m},s=({models:e,introspections:t=[],input_cursors:o,mark:r,encodings:i,width:a,height:s,spec_post_process:u=(e=>e)})=>{if(!e.length)return;let m=Object.entries(i).filter((([e,n])=>"detail_only_proj"!=e)).map((([e,n])=>({type:n.type??"nominal",channel:e,field:n.name??n}))),c={};Object.values(i).filter((({name:e})=>"formulae"==e||"_in"==e.substr(-3))).forEach((({name:e,domain:n})=>{c[e]=n}));let d=[...Object.values(i).map((e=>e.name)).filter((e=>"formula"!=e&&"value"!=e&&"input_cursor_id"!=e&&"_in"!=e.substr(-3)))],p=Object.values(i).filter((({name:e})=>"formula"==e)).map((e=>e.domain));p.length&&(d=[...d,...p[0]]);let f=l({models:e,introspections:t,input_domains:c,input_cursors:o,outputs:d,pivot:0==Object.values(i).filter((e=>"formula"==e.name)).length}),g=n.schema.build(f),_=n.recommend({spec:{data:f,mark:r,encodings:m},chooseBy:"effectiveness"},g),h=n.result.mapLeaves(_.result,(function(e){return e})).items[0].toSpec();return h.data={name:"data"},h.datasets={data:f},"string"==typeof r?r={type:r,tooltip:!0}:null==r.tooltip&&(r.tooltip=!0),h.mark=r,a&&(h.width=a),s&&(h.height=s),"formula"==i.x?.name&&(h.encoding.x.axis={labelAngle:0,orient:"top",labelLimit:90}),"formula"==i.row?.name&&(h.encoding.row.header={labelLimit:70}),Object.entries(i).forEach((([e,n])=>{n.format&&(h.encoding[e].format=n.format,null==h.encoding[e].axis&&(h.encoding[e].axis={format:n.format})),n.scale&&(h.encoding[e].scale=n.scale),n.sort&&(h.encoding[e].sort=n.sort),null!=n.zero&&(h.encoding[e].scale={zero:n.zero}),null!=n.nice&&(h.encoding[e].scale={nice:n.nice}),null!=n.grid&&(h.encoding[e].axis={grid:n.grid}),0==n.legend&&(h.config={legend:{disable:!0}}),null==n.legend&&null!=n.legend&&(h.encoding[e].legend=null),n.independent&&(h.resolve={scale:{[e]:"independent"}})})),u(h)},u=e=>{let n=[...e.cul_functions.values()].filter((e=>"input definition"==e.reason)).map((e=>e.name)).sort(),t=[...e.cul_functions.values()].filter((e=>"definition"==e.reason&&-1==n.indexOf(e.name+"_in")));return`formula | ${n.join(" | ")}\n-------- | ${n.map((e=>":--------:")).join(" | ")}\n | ${n.map((e=>"\x3c!--<img width=80/>--\x3e")).join(" | ")}\n${t.map((t=>`${t.name} | ${n.map((n=>e.cul_input_map["0_"+t.name].has(n)?"✔️":"")).join(" | ")}`)).join("\n")}`},m=({models:e,input_domains:n,input_cursors:r,outputs:a,pivot:l=!0})=>{if(0==l&&console.error("arrow version of calcudata doesnt support pivot false"),!e.length)return;let s={model_id:e.map(((e,n)=>n)),input_cursor_id:r.map(((e,n)=>n))};Object.entries(n).forEach((([e,n])=>{s[e]=n}));let u=i(Object.entries(s).map((([e,n])=>({[e]:n}))));u=u.map((e=>({...r[e.input_cursor_id],...e})));let m={};return Object.keys(n).forEach((e=>{m[e]=u.map((n=>n[e]))})),m.model_id=u.map((e=>e.model_id)),m.input_cursor_id=u.map((e=>e.input_cursor_id)),a.forEach((n=>{m[n]=u.map((t=>e[t.model_id][n](t)))})),t(o(m))};function c(e,n){return e+n}export{c as add,l as calcudata,m as calcudata_arrow,s as calcuvizspec,i as cartesianProduct,u as function_inputs_table,r as sayHello};export default null;
